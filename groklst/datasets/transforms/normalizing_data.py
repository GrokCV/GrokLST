# Copyright (c) OpenMMLab. All rights reserved.
# import os.path as osp
from typing import List, Optional, Tuple, Union
import scipy.io as sio
import mmcv
import numpy as np
from mmcv.transforms import BaseTransform
from mmagic.registry import TRANSFORMS


@TRANSFORMS.register_module()
class NormalizeGrokLSTData(BaseTransform):
    """Normalize LST data with the given norm_paras_dict.

    Required keys are the keys in attribute "keys", added or modified keys are
    the keys in attribute "keys" and these keys with postfix '_norm_cfg'.
    It also supports normalizing a list of images.

    New Keys: None


    Args:
        key (str): The key of results, and the results[key] to be normalized.
        norm_flag (int): The type of normalization, norm_flag=0 means do not norm; norm_flag=1 means do z-score; norm_flag=2 mean do min-max!"
        norm_paras_dict (dict): Normalization parameter dictionary, including "mean", "std", "min" and "max" of data.
        channel_idx_to_gui_mapping (dict): Ensure that each channel data to be normalized matches the key of the normalization parameter dictionary.
    """

    def __init__(
        self,
        key: str = "hr_guidance",
        norm_flag: int = 0,
        norm_paras_dict: dict = dict(),
    ) -> None:
        self.key = key
        self.norm_flag = norm_flag
        self.norm_paras_dict = norm_paras_dict

    def transform(self, results: dict) -> dict:
        """transform function.

        Args:
            results (dict): A dict containing the necessary information and
                data for augmentation.

        Returns:
            dict: A dict containing the processed data and information.
        """

        assert self.norm_flag in [
            0,
            1,
            2,
        ], f"norm flag not in [0, 1, 2]! flag=0 means do not norm; flag=1 means do z-score; flag=2 mean do min-max!"

        data = results[self.key]
        # see LoadGrokLSTMatFile for details about results['ori_band_name_to_idx_dict'].
        mapping = results.get("ori_band_name_to_idx_dict", None)
        # see RandomDropBands for details about results['gui_mask'] and results['saved_band_name_to_idx_dict'].
        # key: 'gui_mask' generated by RandomDropBands.
        # see file groklst/datasets/transforms/dropping_bands.py for details.
        gui_mask = results.get("gui_mask", None)
        drop_band = results.get("drop_band", None)
        with_zero_padding = results.get("with_zero_padding", None)
        if drop_band and (not with_zero_padding):  # drop_band and not zero padding!
            mapping = results.get("saved_band_name_to_idx_dict", None)
        h, w, c = data.shape

        if self.norm_flag == 1:  # z-score
            # if not with_zero_padding: # (not drop bands) or (drop bands and not zero padding)
            if (not drop_band) or (drop_band and not with_zero_padding):
                for key, channel_idx in mapping.items():
                    mean = self.norm_paras_dict[key]["mean"]
                    std = self.norm_paras_dict[key]["std"]
                    assert std != 0, f"std==0!!!"
                    # z-score norm
                    _data = data[..., int(channel_idx)]
                    data[..., int(channel_idx)] = (_data - mean) / std
            else:  # 　(drop_band and with_zero_padding)
                for key, channel_idx in mapping.items():
                    # 丢弃的波段不做归一化
                    if drop_band and (gui_mask[channel_idx] == 0):
                        continue
                    else:
                        mean = self.norm_paras_dict[key]["mean"]
                        std = self.norm_paras_dict[key]["std"]
                        assert std != 0, f"std==0!!!"
                        # z-score norm
                        _data = data[..., int(channel_idx)]
                        data[..., int(channel_idx)] = (_data - mean) / std
        elif self.norm_flag == 2:  # min-max
            if not with_zero_padding:
                for key, channel_idx in mapping.items():
                    min = self.norm_paras_dict[key]["min"]
                    max = self.norm_paras_dict[key]["max"]
                    assert min != max, f"min=max!!!"
                    # min-max norm
                    _data = data[..., int(channel_idx)]
                    data[..., int(channel_idx)] = (_data - min) / (max - min)
            else:  # 　(drop_band and with_zero_padding)
                for key, channel_idx in mapping.items():
                    # 丢弃的波段不做归一化
                    if drop_band and (gui_mask[channel_idx] == 0):
                        continue
                    else:
                        min = self.norm_paras_dict[key]["min"]
                        max = self.norm_paras_dict[key]["max"]
                        assert min != max, f"min=max!!!"
                        # min-max norm
                        _data = data[..., int(channel_idx)]
                        data[..., int(channel_idx)] = (_data - min) / (max - min)

        results[self.key] = data

        return results


@TRANSFORMS.register_module()
class NormalizeOpticalSARData(BaseTransform):
    """Normalize optical & sar data.

    Required keys are the keys in attribute "keys", added or modified keys are
    the keys in attribute "keys" and these keys with postfix '_norm_cfg'.
    It also supports normalizing a list of images.

    New Keys: None


    Args:
        key (str): The key of results, and the results[key] to be normalized.
        norm_flag (int): The type of normalization, only support "minmax", "zscore", and None.
    """

    def __init__(
        self,
        key: str = "sar_vh",
        norm_flag: Optional[str] = 'zscore',
        mean: Optional[Union[float, List[float]]] = None,
        std: Optional[Union[float, List[float]]] = None,
        min: Optional[Union[float, List[float]]] = None,
        max: Optional[Union[float, List[float]]] = None,
    ) -> None:
        self.key = key
        assert norm_flag in [
            'zscore',
            'minmax',
            None,
        ], "norm_flag should be in ['zscore', 'minmax', None]!"
        assert (
            norm_flag == 'zscore' and (mean is not None) and (std is not None)
        ), "when norm_flag is 'zscore', you should provide 'mean' and 'std'! "
        assert (
            norm_flag == 'minmax' and (min is not None) and (max is not None)
        ), "when norm_flag is 'minmax', you should provide 'min' and 'max'! "
        self.norm_flag = norm_flag
        self.mean = mean
        self.std = std
        self.min = min
        self.max = max

    def transform(self, results: dict) -> dict:
        """transform function.

        Args:
            results (dict): A dict containing the necessary information and
                data for augmentation.

        Returns:
            dict: A dict containing the processed data and information.
        """
        if self.norm_flag is None:
            return results

        if results.get(self.key, None) is None:
            return results
        data = results[self.key]

        if data.ndim == 2:
            H, W = data.shape
            data = data.reshape(H, W, 1)

        H, W, C = data.shape

        # Ensure mean, std, min and max are in list format and match the number of channels
        if isinstance(self.mean, float):
            mean_values = [self.mean] * C
        elif isinstance(self.mean, list) and len(self.mean) == C:
            mean_values = self.mean
        else:
            raise ValueError(
                "mean should be a float or a list with the correct number of values"
            )

        if isinstance(self.std, float):
            std_values = [self.std] * C
        elif isinstance(self.std, list) and len(self.std) == C:
            std_values = self.std
        else:
            raise ValueError(
                "std should be a float or a list with the correct number of values"
            )

        if self.norm_flag == "zscore":
            # Ensure mean and std are in list format and match the number of channels
            # mean
            if isinstance(self.mean, float):
                mean_values = [self.mean] * C
            elif isinstance(self.mean, list) and len(self.mean) == C:
                mean_values = self.mean
            # std
            if isinstance(self.std, float):
                std_values = [self.std] * C
            elif isinstance(self.std, list) and len(self.std) == C:
                std_values = self.std
            # z-score
            data = (data - np.array(mean_values)) / np.array(std_values + 1e-8)
        elif self.norm_flag == "minmax":
            # Ensure min and max are in list format and match the number of channels
            # min
            if isinstance(self.min, float):
                mean_values = [self.min] * C
            elif isinstance(self.min, list) and len(self.min) == C:
                mean_values = self.min
            # max
            if isinstance(self.max, float):
                std_values = [self.max] * C
            elif isinstance(self.max, list) and len(self.max) == C:
                std_values = self.max
            # z-score
            data = (data - np.array(self.min)) / (
                np.array(self.max) - np.array(self.min)
            )

        results[self.key] = data

        return results
